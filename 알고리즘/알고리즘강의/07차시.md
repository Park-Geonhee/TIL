### 정렬 알고리즘 비교

---

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| :-----------: | :--------------: | :---------: | :----------------------------------------------------------- |
|   선택 정렬   |      $O(N^2)$      |    $O(N)$     | 아이디어가 매우 간단함                                       |
|   삽입 정렬   |      $O(N^2)$      |    $O(N)$     | 데이터가 거의 정렬되어 있을 때 가장 빠름                     |
|    퀵 정렬    |     $O(NlogN)$     |    $O(N)$     | 대부분의 경우에 가장 적합, 충분히 빠름                       |
|   계수 정렬   |      $O(N+k)$      |   $O(N+K)$    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작 |

- 대부분의 프로그래밍 언어에서 지원하는 표준 정렬 라이브러리는 최악의 경우에도 ***O(NlogN)***을 보장하도록 설계되어 있음

- 선택 정렬과 기본 정렬 라이브러리 수행 시간 비교
- (여기에 코드 입력)



#### 문제 ) 두 배열의 원소 교체

---

- 두 개의 배열 A, B 가 있다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수입니다.
- 최대 K번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말합니다.
- 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것입니다.
- N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하세요.



- 예를들어, N = 5, K = 3이고 배열 A 와 B는 다음과 같습니다.
  - A = [1,2,5,4,3]
  - B = [5,5,6,6,5]
- 이 경우, 다음과 같이 세 번의 연산을 수행할 수 있습니다.
  - 연산 1) 배열 A의 원소 '1'과 배열 B의 원소 '6'을 바꾸기
  - 연산 2) 배열 A의 원소 '2'와 배열 B의 원소 '6'을 바꾸기
  - 연산 3)배열 A의 원소 '3'과 배열 B의 원소 '5'를 바꾸기
- 세 번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성됩니다.
  - A = [6,6,5,4,5]
  - B = [3,5,1,2,5]
- 이 때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없습니다.

---

- (python ans)
- (c++ ans)
- (java ans : github)